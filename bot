"""
bybit_bbu_ultra_bot_fixed.py
Auto trader for Bybit USDT Perpetual (v5). Fixed and improved version.
- Fixes bugs (typos, use of unconfirmed candle, crash points)
- Adds: checking existing positions, symbol filters, lot/tick rounding, logging, safe mode, basic anti-overtrade (one active position per symbol), improved error handling & backoff
- nanonac
import hashlib
import requests
import json
import math
import logging
from typing import List, Dict, Optional
import pandas as pd
import numpy as np
from datetime import datetime, timezone

# -------------------------
# CONFIG
# -------------------------
API_KEY = "4n1HrBYslBFpEBLCO3"
API_SECRET = "a0OQKam1ESYSRFC6P8QZ9Kp89QbrKe0OhKCl"
USE_TESTNET = True  # -> True: testnet, False: production

# Trading settings (from your request)
LEVERAGE = 10
RISK_PORTION = 0.5   # 50% of balance per trade (note: futures with leverage)
TP_PCT = 0.05        # 5% take profit
SL_PCT = 0.05        # 3% stop loss
TIMEFRAME = "1h"     # 1 hour klines

# Indicator params (as on your screenshot)
BB_LEN = 9
BB_MULT = 1
VOL_LEN = 19
VOL_MULT = 1.3
RSI_LEN = 8
MFI_LEN = 8
MACD_FAST = 10
MACD_SLOW = 21
MACD_SIG = 7
EMA200_LEN = 200
STRUCT_LEN = 20

# Operation settings
SLEEP_BETWEEN_CYCLES = 60 * 10  # every 10 minutes
KLIMIT = 500  # number of klines to fetch (make sure enough history)
MAX_API_ERRORS_BEFORE_BACKOFF = 5
BACKOFF_SECONDS = 60

# Safe mode: if True, the bot will only simulate orders (log them) instead of sending to Bybit
SAFE_MODE = False

# Active symbols set: avoid opening multiple positions on the same symbol concurrently
active_symbols = set()

# Bybit endpoints (v5)
if USE_TESTNET:
    BASE_URL = "https://api-testnet.bybit.com"
else:
    BASE_URL = "https://api.bybit.com"

# -------------------------
# Logging
# -------------------------
LOGFILE = "bybit_bbu_ultra_bot.log"
logging.basicConfig(
    filename=LOGFILE,
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
)
console = logging.StreamHandler()
console.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s')
console.setFormatter(formatter)
logging.getLogger('').addHandler(console)

# -------------------------
# Helpers: Bybit v5 signing
# Docs: X-BAPI-API-KEY, X-BAPI-TIMESTAMP, X-BAPI-SIGN required (HMAC_SHA256)
# signature string = timestamp + apiKey + recvWindow + (queryString | bodyString)  (per docs)
# -------------------------
RECV_WINDOW = "5000"


def _now_ts_ms() -> str:
    return str(int(time.time() * 1000))


def sign_v5(api_key: str, api_secret: str, timestamp: str, recv_window: str, body_str: str) -> str:
    """
    Create X-BAPI-SIGN for Bybit v5.
    Prehash string = timestamp + apiKey + recvWindow + bodyStr
    For GETs we will pass empty body_str if there is no body.
    """
    prehash = timestamp + api_key + recv_window + body_str
    signature = hmac.new(api_secret.encode('utf-8'), prehash.encode('utf-8'), hashlib.sha256).hexdigest()
    return signature


def auth_headers(body_str: str = "") -> Dict[str, str]:
    ts = _now_ts_ms()
    sign = sign_v5(API_KEY, API_SECRET, ts, RECV_WINDOW, body_str)
    return {
        "Content-Type": "application/json",
        "X-BAPI-API-KEY": API_KEY,
        "X-BAPI-TIMESTAMP": ts,
        "X-BAPI-RECV-WINDOW": RECV_WINDOW,
        "X-BAPI-SIGN": sign
    }

# -------------------------
# Market and account helpers
# -------------------------

def safe_request_get(url: str, params: Dict = None, headers: Dict = None, timeout: int = 15) -> dict:
    """Wrapper around requests.get with error handling and logging."""
    try:
        r = requests.get(url, params=params, headers=headers, timeout=timeout)
        r.raise_for_status()
        return r.json()
    except Exception as e:
        logging.warning(f"GET {url} failed: {e}")
        raise


def safe_request_post(url: str, body: Dict, headers: Dict = None, timeout: int = 15) -> dict:
    """Wrapper around requests.post with error handling and logging."""
    body_str = json.dumps(body)
    try:
        r = requests.post(url, headers=headers or auth_headers(body_str), data=body_str, timeout=timeout)
        r.raise_for_status()
        return r.json()
    except Exception as e:
        logging.warning(f"POST {url} failed: {e} body={body}")
        raise


def get_all_tickers(category: str = "linear") -> List[Dict]:
    """
    GET /v5/market/tickers?category=linear
    Returns list of tickers (see Bybit docs).
    """
    url = f"{BASE_URL}/v5/market/tickers"
    params = {"category": category}
    data = safe_request_get(url, params=params)
    if data.get("retCode", 0) != 0:
        raise RuntimeError(f"Error fetching tickers: {data}")
    return data["result"]["list"]


def top_n_gainers(n: int = 15) -> List[str]:
    tickers = get_all_tickers("linear")

    def pct(t):
        try:
            return float(t.get("prevPrice24h", 0))
        except Exception:
            return 0.0

    sorted_t = sorted(tickers, key=lambda x: pct(x), reverse=True)
    syms = [t["symbol"] for t in sorted_t[:n]]
    return syms


def get_klines(symbol: str, interval: str = "1h", limit: int = 200) -> pd.DataFrame:
    """
    GET /v5/market/kline?category=linear&symbol=BTCUSDT&interval=1h&limit=200
    Builds a pandas DataFrame with columns: open, high, low, close, volume and datetime index
    """
    url = f"{BASE_URL}/v5/market/kline"
    params = {"category": "linear", "symbol": symbol, "interval": interval, "limit": limit}
    data = safe_request_get(url, params=params)
    if data.get("retCode", 0) != 0:
        raise RuntimeError(f"Kline error for {symbol}: {data}")
    rows = data["result"]["list"]
    # Ensure rows non-empty
    if not rows:
        raise RuntimeError("Empty kline response")
    # Typical row format varies; map first 6 to open/high/low/close/volume/start
    mapped = []
    for r in rows:
        # r may already be a dict or a list; try to handle list
        if isinstance(r, list):
            mapped.append({
                "open": r[0], "high": r[1], "low": r[2], "close": r[3], "volume": r[4], "start": r[5]
            })
        elif isinstance(r, dict):
            mapped.append({
                "open": r.get("open"), "high": r.get("high"), "low": r.get("low"), "close": r.get("close"), "volume": r.get("volume"), "start": r.get("start")
            })
    df = pd.DataFrame(mapped)
    for c in ["open", "high", "low", "close", "volume"]:
        df[c] = pd.to_numeric(df[c], errors="coerce")
    df["start"] = pd.to_datetime(df["start"], unit="ms")
    df = df.set_index("start")
    return df


def get_usdt_balance() -> float:
    """
    Tries to read USDT balance from /v5/account/wallet-balance or /v5/account/balance
    Returns float available USDT.
    """
    # Try wallet-balance first
    url = f"{BASE_URL}/v5/account/wallet-balance"
    body = {"coin": "USDT"}
    body_str = json.dumps(body)
    try:
        headers = auth_headers(body_str)
        data = safe_request_get(url, params=body, headers=headers)
        if data.get("retCode", 0) == 0:
            balances = data["result"].get("list", [])
            for item in balances:
                if item.get("coin") == "USDT":
                    return float(item.get("walletBalance", 0) or 0)
    except Exception:
        logging.info("wallet-balance failed, trying /v5/account/balance")

    # fallback - try another endpoint
    url2 = f"{BASE_URL}/v5/account/balance"
    try:
        headers2 = auth_headers("{}")
        resp2 = safe_request_get(url2, params={"coin": "USDT"}, headers=headers2)
        if resp2.get("retCode", 0) == 0:
            lst = resp2["result"].get("list", [])
            for item in lst:
                if item.get("coin") == "USDT":
                    return float(item.get("availableBalance", 0) or 0)
    except Exception as e:
        logging.warning("Failed to fetch USDT balance: %s", e)

    logging.warning("USDT balance not found or API responded unexpectedly.")
    return 0.0

# -------------------------
# Symbol info and rounding helpers
# -------------------------

def get_symbol_info(symbol: str) -> Dict:
    """Fetch symbol info (pricePrecision, lotSize, minQty etc.) from /v5/market/symbols"""
    url = f"{BASE_URL}/v5/market/symbols"
    params = {"symbol": symbol}
    data = safe_request_get(url, params=params)
    if data.get("retCode", 0) != 0:
        raise RuntimeError(f"Error fetching symbol info: {data}")
    # result may be list
    lst = data["result"].get("list", [])
    if not lst:
        return {}
    return lst[0]


def round_qty_by_symbol(symbol_info: Dict, qty: float) -> float:
    """Round qty according to lot size/step size info returned by Bybit (if available)."""
    try:
        base_precision = symbol_info.get("basePrecision") or symbol_info.get("lotSizeFilter", {}).get("min_trading_qty")
        # fallback: round down to 4 decimals
        if base_precision is None:
            return math.floor(qty * 10000) / 10000.0
        # bybit sometimes returns integers - infer decimals
        # if base_precision is int like 4 -> round to 4 decimals
        if isinstance(base_precision, int) or (isinstance(base_precision, str) and base_precision.isdigit()):
            dec = int(base_precision)
            factor = 10 ** dec
            return math.floor(qty * factor) / factor
    except Exception:
        pass
    return math.floor(qty * 10000) / 10000.0

# -------------------------
# Indicator implementations (pandas)
# -------------------------

def bbands(df: pd.DataFrame, length=BB_LEN, mult=BB_MULT):
    basis = df["close"].rolling(length).mean()
    dev = df["close"].rolling(length).std() * mult
    upper = basis + dev
    lower = basis - dev
    return basis, upper, lower


def sma(series: pd.Series, n: int):
    return series.rolling(n).mean()


def ema(series: pd.Series, n: int):
    return series.ewm(span=n, adjust=False).mean()


def rsi(series: pd.Series, n=RSI_LEN):
    delta = series.diff()
    up = delta.clip(lower=0)
    down = -1 * delta.clip(upper=0)
    ma_up = up.ewm(alpha=1 / n, adjust=False).mean()
    ma_down = down.ewm(alpha=1 / n, adjust=False).mean()
    rs = ma_up / (ma_down + 1e-9)
    return 100 - (100 / (1 + rs))


def mfi(df: pd.DataFrame, n=MFI_LEN):
    tp = (df["high"] + df["low"] + df["close"]) / 3
    raw_mf = tp * df["volume"]
    pos = raw_mf.where(tp > tp.shift(1), 0.0)
    neg = raw_mf.where(tp < tp.shift(1), 0.0)
    sum_pos = pos.rolling(n).sum()
    sum_neg = neg.rolling(n).sum()
    mfi_series = 100 * (sum_pos / (sum_pos + sum_neg + 1e-9))
    mfi_series = mfi_series.fillna(50)
    return mfi_series


def macd_hist(series: pd.Series, fast=MACD_FAST, slow=MACD_SLOW, sig=MACD_SIG):
    fast_ema = ema(series, fast)
    slow_ema = ema(series, slow)
    macd_line = fast_ema - slow_ema
    signal = ema(macd_line, sig)
    hist = macd_line - signal
    return macd_line, signal, hist

# -------------------------
# Signal function (translates your Pine logic)
# -------------------------

def compute_signal(df: pd.DataFrame) -> Dict[str, bool]:
    """
    Compute long/short signals for the latest confirmed candle (use the last closed candle).
    Returns dict { 'long': bool, 'short': bool }
    """
    if len(df) < max(BB_LEN, VOL_LEN, MACD_SLOW, EMA200_LEN, STRUCT_LEN) + 5:
        return {"long": False, "short": False}

    # use confirmed candle = second last (last may be forming)
    basis, upper, lower = bbands(df, BB_LEN, BB_MULT)
    vol_sma = sma(df["volume"], VOL_LEN)
    vol_now = df["volume"] > vol_sma * VOL_MULT
    vol_prev = df["volume"].shift(1) > vol_sma * VOL_MULT
    vol_confirm = vol_now & vol_prev

    rsi_s = rsi(df["close"], RSI_LEN)
    mfi_s = mfi(df, MFI_LEN)
    macd_line, macd_signal, macd_h = macd_hist(df["close"], MACD_FAST, MACD_SLOW, MACD_SIG)
    mom_count = ((rsi_s > 40).astype(int) + (mfi_s > 40).astype(int) + (macd_h > 0).astype(int))
    mom_confirm = mom_count >= 2

    ema200 = ema(df["close"], EMA200_LEN)

    # structure
    prev_low = df["low"].rolling(STRUCT_LEN).min().shift(1)
    prev_high = df["high"].rolling(STRUCT_LEN).max().shift(1)
    struct_bull = df["low"] > prev_low
    struct_bear = df["high"] < prev_high

    # BB reversal
    was_below = df["close"].shift(1) < lower.shift(1)
    back_inside_bull = (df["close"] > lower) & (df["close"] > df["open"])
    bb_reversal_long = was_below & back_inside_bull

    was_above = df["close"].shift(1) > upper.shift(1)
    back_inside_bear = (df["close"] < upper) & (df["close"] < df["open"])
    bb_reversal_short = was_above & back_inside_bear

    # basis break
    basis_break_long = (df["close"].gt(basis)) & (df["close"].shift(1).le(basis.shift(1))) & mom_confirm & vol_now
    basis_break_short = (df["close"].lt(basis)) & (df["close"].shift(1).ge(basis.shift(1))) & mom_confirm & vol_now

    # final: check last confirmed closed candle (index -2)
    i = -2
    htf_bull = df["close"].iloc[i] > ema200.iloc[i]
    htf_bear = df["close"].iloc[i] < ema200.iloc[i]

    long_signal = ((bb_reversal_long.iloc[i] & vol_confirm.iloc[i] & mom_confirm.iloc[i] & htf_bull & struct_bull.iloc[i]) |
                   (basis_break_long.iloc[i] & htf_bull & struct_bull.iloc[i]))
    short_signal = ((bb_reversal_short.iloc[i] & vol_confirm.iloc[i] & mom_confirm.iloc[i] & htf_bear & struct_bear.iloc[i]) |
                    (basis_break_short.iloc[i] & htf_bear & struct_bear.iloc[i]))

    return {"long": bool(long_signal), "short": bool(short_signal)}

# -------------------------
# Trading actions
# -------------------------

def set_leverage(symbol: str, leverage: int = LEVERAGE, category: str = "linear") -> dict:
    url = f"{BASE_URL}/v5/position/set-leverage"
    body = {"category": category, "symbol": symbol, "leverage": str(leverage)}
    body_str = json.dumps(body)
    headers = auth_headers(body_str)
    data = safe_request_post(url, body, headers=headers)
    return data


def place_market_order(symbol: str, side: str, qty: float, category: str = "linear") -> dict:
    """
    POST /v5/order/create
    orderType=Market, qty as number of contracts
    This wrapper respects SAFE_MODE: if SAFE_MODE==True it will only log the order.
    """
    url = f"{BASE_URL}/v5/order/create"
    body = {
        "category": category,
        "symbol": symbol,
        "side": side,
        "orderType": "Market",
        "qty": str(qty),
        "timeInForce": "ImmediateOrCancel",
        "reduceOnly": False,
        "closeOnTrigger": False
    }
    logging.info("Placing order (simulated=%s): %s", SAFE_MODE, body)
    if SAFE_MODE:
        # simulate response structure minimally
        return {"retCode": 0, "retMsg": "OK (simulated)", "result": {"orderId": "simulated-12345"}}

    body_str = json.dumps(body)
    headers = auth_headers(body_str)
    data = safe_request_post(url, body, headers=headers)
    return data


def set_tp_sl(symbol: str, takeProfit: float = None, stopLoss: float = None, category: str = "linear") -> dict:
    """
    POST /v5/position/trading-stop
    Use to set TP/SL for the active position.
    We'll attempt to determine positionIdx by querying positions list.
    """
    position_idx = 0
    # try to detect actual positionIdx
    try:
        pos = get_open_position(symbol)
        if pos:
            position_idx = pos.get("positionIdx", 0)
    except Exception:
        pass

    url = f"{BASE_URL}/v5/position/trading-stop"
    body = {"category": category, "symbol": symbol, "positionIdx": position_idx}
    if takeProfit is not None:
        body["takeProfit"] = str(takeProfit)
    if stopLoss is not None:
        body["stopLoss"] = str(stopLoss)
    logging.info("Setting TP/SL (simulated=%s): %s", SAFE_MODE, body)
    if SAFE_MODE:
        return {"retCode": 0, "retMsg": "OK (simulated)", "result": {}}
    body_str = json.dumps(body)
    headers = auth_headers(body_str)
    data = safe_request_post(url, body, headers=headers)
    return data


def get_open_position(symbol: str) -> Optional[Dict]:
    """Get open position for a symbol (if any). Returns position dict or None."""
    url = f"{BASE_URL}/v5/position/list"
    params = {"category": "linear", "symbol": symbol}
    try:
        headers = auth_headers("{}")
        data = safe_request_get(url, params=params, headers=headers)
        if data.get("retCode", 0) == 0:
            lst = data["result"].get("list", [])
            for p in lst:
                # positionSize > 0 indicates open
                if float(p.get("size", 0)) > 0:
                    return p
    except Exception as e:
        logging.warning("Failed to fetch positions: %s", e)
    return None

# -------------------------
# Core loop helpers
# -------------------------

def compute_order_qty(usdt_balance: float, price: float, leverage: int = LEVERAGE, portion: float = RISK_PORTION) -> float:
    """
    Compute approximate qty for market order:
    notional = balance * portion * leverage
    qty = notional / price
    NOTE: actual exchange qty rounding and minQty requirements must be handled in production.
    """
    notional = usdt_balance * portion * leverage
    qty = notional / price if price > 0 else 0.0
    return qty

# -------------------------
# Main loop
# -------------------------

def main_loop():
    logging.info("Starting bot. TESTNET=%s SAFE_MODE=%s", USE_TESTNET, SAFE_MODE)
    api_error_count = 0
    while True:
        try:
            symbols = top_n_gainers(15)
            logging.info("Top-15: %s", symbols)
        except Exception as e:
            logging.error("Error fetching top gainers: %s", e)
            api_error_count += 1
            if api_error_count >= MAX_API_ERRORS_BEFORE_BACKOFF:
                logging.warning("Too many API errors. Backing off %s seconds.", BACKOFF_SECONDS)
                time.sleep(BACKOFF_SECONDS)
                api_error_count = 0
            else:
                time.sleep(10)
            continue

        # read account balance once
        try:
            usdt_balance = get_usdt_balance()
            logging.info("USDT balance: %s", usdt_balance)
        except Exception as e:
            logging.error("Balance fetch error: %s", e)
            usdt_balance = 0.0

        for sym in symbols:
            try:
                # skip symbols we already have an active managed position for (anti-overtrade)
                if sym in active_symbols:
                    logging.info("Skipping %s because active position present (anti-overtrade).", sym)
                    continue

                df = get_klines(sym, interval=TIMEFRAME, limit=KLIMIT)
                sig = compute_signal(df)
                # use confirmed last-closed candle price
                latest_price = float(df["close"].iloc[-2])
                logging.info("%s price %s -> signal %s", sym, latest_price, sig)

                if sig["long"] or sig["short"]:
                    side = "Buy" if sig["long"] else "Sell"
                    logging.info("Signal %s for %s at %s", side, sym, latest_price)

                    # Check existing position on symbol
                    existing = get_open_position(sym)
                    if existing:
                        logging.info("Position already open for %s -> skipping entry. pos=%s", sym, existing)
                        # add to active_symbols to avoid trying repeatedly
                        active_symbols.add(sym)
                        continue

                    # set leverage (best effort)
                    try:
                        set_leverage(sym, LEVERAGE)
                    except Exception as e:
                        logging.warning("Leverage set error for %s: %s", sym, e)

                    # compute qty
                    qty = compute_order_qty(usdt_balance, latest_price, LEVERAGE, RISK_PORTION)

                    # get symbol info and round qty properly
                    try:
                        info = get_symbol_info(sym)
                        qty = round_qty_by_symbol(info, qty)
                    except Exception:
                        qty = math.floor(qty * 10000) / 10000.0

                    if qty <= 0:
                        logging.info("Computed qty <= 0 for %s, skip", sym)
                        continue

                    # place market order
                    try:
                        res = place_market_order(sym, side, qty)
                        logging.info("Placed order response: %s", res)
                        # if order success - mark symbol as active
                        if res.get("retCode", 0) == 0:
                            active_symbols.add(sym)
                    except Exception as e:
                        logging.error("Order placement error for %s: %s", sym, e)
                        continue

                    # compute TP/SL prices based on side
                    if side == "Buy":
                        tp_price = latest_price * (1 + TP_PCT)
                        sl_price = latest_price * (1 - SL_PCT)
                    else:
                        tp_price = latest_price * (1 - TP_PCT)
                        sl_price = latest_price * (1 + SL_PCT)

                    # set take profit and stop loss (trading-stop) - best effort
                    try:
                        set_tp_sl(sym, takeProfit=round(tp_price, 6), stopLoss=round(sl_price, 6))
                        logging.info("Set TP %s and SL %s for %s", tp_price, sl_price, sym)
                    except Exception as e:
                        logging.warning("Failed to set TP/SL for %s: %s", sym, e)

                # small delay between symbols to avoid rate limits
                time.sleep(0.5)
            except Exception as e:
                logging.exception("Error processing %s: %s", sym, e)
                time.sleep(0.5)
                continue

        logging.info("Cycle complete. Sleeping %s seconds.", SLEEP_BETWEEN_CYCLES)
        time.sleep(SLEEP_BETWEEN_CYCLES)


if __name__ == "__main__":
    try:
        main_loop()
    except KeyboardInterrupt:
        logging.info("Bot stopped by user")
    except Exception as e:
        logging.exception("Fatal error: %s", e)
